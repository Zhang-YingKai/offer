数据结构
HashMap的原理，内部数据结构？
底层使用哈希表（数组 + 链表），当链表过长会将链表转成 红黑树以实现 O(logn) 时间复杂度内查找
讲一下 HashMap 中 put 方法过程？
对 Key 求 Hash 值，然后再计算 下标。
如果没有碰撞，直接放入桶中，
如果碰撞了，以链表的方式链接到后面，
如果链表长度超过阀值（TREEIFY_THRESHOLD == 8），就把链表转成红黑树。
如果节点已经存在就替换旧值
如果桶满了（容量 * 加载因子），就需要 resize。
HashMap 中 hash 函数怎么是是实现的？ 还有哪些 hash 的实现方式？
高 16bit 不变，低 16bit 和高 16bit 做了一个异或
（n - 1） & hash --> 得到下标
还有哪些 Hash 实现方式：可以参考之前的博客 Effective Java 学习笔记 -- hashCode()
HashMap 怎样解决冲突，讲一下扩容过程，假如一个值在原数组中，现在移动了新数组，位置肯定改变了，那是什么定位到在这个值新数组中的位置，
将新节点加到链表后，
容量扩充为原来的两倍，然后对每个节点重新计算哈希值。
这个值只可能在两个地方，一个是原下标的位置，另一种是在下标为 <原下标+原容量> 的位置。
抛开 HashMap，hash 冲突有那些解决办法？
开放定址，链地址法
针对 HashMap 中某个 Entry 链太长，查找的时间复杂度可能达到 O(n)，怎么优化？
将链表转为红黑树， JDK1.8 已经实现了。
数组和 ArrayList 的区别；
数组可以包含基本类型和对象类型，ArrayList 只能包含对象类型
数组大小固定，ArrayList 大小可以动态变化
ArrayList 提供了更多的特性（addAll、removeAll）。
Arraylist 如何实现排序
Collections.sort(List<T> list);
sort(List<T> list, Comparator<? super T> c);
HashMap ，HashTable 区别
HashMap、ConcurrentHashMap 区别。
ConcurrentHashMap 两个 hash 过程，第一次找到所在的桶，并将桶锁定，第二次执行写操作。
ConcurrentHashMap原理，jdk1.8 后有哪些改变（引入CAS等）
TreeMap 和 TreeSet 区别和实现原理
TreeSet 底层是 TreeMap，TreeMap 是基于红黑树来实现的。
如果想实现一个线程安全的队列，可以怎么实现？
知道 LRU 吗，20分钟基于 HashMap 实现一个 LRU 算法，面试官给个地址，进去写代码，面试官远程看
如何设计实现一个LRU Cache？
二叉树的遍历方式，前序、中序、后序和层序
可以再写一篇了。。
常见的排序算法时间复杂度（排序算法实现也要重点掌握）
常见排序算法实现(Java)
红黑树的特点及相比平衡二叉树的优点（先介绍各自特点）？
红黑树
每个节点要么是红色，要么是黑色。
根节点永远是黑色的。
所有的叶节点都是空节点（即 null），并且是黑色的。
每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点）
从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。
平衡二叉树
任何节点的两个儿子子树的高度最大差别为一
红黑树并不追求“完全平衡”——它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。
B+树的了解
多分支结构有效降低了树的高度
B 树的各种操作能使 B 树保持较低的高度，从而达到有效避免磁盘过于频繁的查找存取操作，从而有效提高查找效率
Trie-Tree 原理及其应用；
字典树
特点
根节点不包含字符，除根节点外的每一个子节点都包含一个字符。
从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。
每个节点的所有子节点包含的字符互不相同。
核心思想是空间换时间
应用
字符串检索
词频统计
